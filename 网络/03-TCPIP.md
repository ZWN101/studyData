以太网：目前应用最普遍的局域网技术，取代了其他局域网技术如：令牌环、FDDI、ARCNET

局域网 城域网 广域网

### TCP/IP

TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议

### TCP/IP协议的组成

TCP/IP协议在一定程度上参考了OSI的体系结构。OSI模型从下到上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP协议中，被简化成了五层。

<img src="C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210202200737502.png" alt="image-20210202200737502" style="zoom: 50%;" />

### 通信过程

在网络通信的过程中，将发出数据的主机成为源主机，接收数据的主机成为目的主机，当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用程序先将数据交给应用层，**应用层**加上必要的控制信息形成**报文流**，向下传给传输层。**传输层**将接收到的数据单元加上本层的控制信息，形成**报文段、数据报**，再交给网络层。**网络层**加上本层的控制信息，形成**IP数据报**，传给数据链路层。**数据链路层**将网络层交下来的IP数据报组装成**帧**，并以比特流的形式传给物理层（网络硬件），数据就离开的源主机

### 物理层

电脑连接起来的物理手段（网线）

### 数据链路层

**对电信号进行分组形成具有特殊意义的帧，然后在同一个子网内以广播的形式通过物理介质发送给接收方**

* **定义**

  通过以太网协议在**同一个子网络**里发送数据包（帧）

* **以太网协议**

  以太网规定：一组电信号构成一个数据包，叫做帧，每一个帧分为标头和数据

  标头包含：发送者（MAC地址）、接收者（MAC地址）、数据类型等

  数据包含：数据包的具体内容

  如果数据很长，就必须分割成多个包进行发送

* **MAC地址**

  **网卡的地址，就是数据包的发送地址和接收地址，叫做MAC地址**

  以太网规定，连接网络的所有设备，都必须具有网卡接口，每块网卡出生的时候，都有一个世界上独一无二的MAC地址。

* **广播**

  有了MAC地址，同一网络内的两台主机就可以通信了。

  以太网采取广播的形式，把数据包发送给子网内的所有主机，子网内的每一台主机在接收到这个包以后，都会读取首部里的MAC地址，与自己的MAC地址进行对比，相同就进行下一步的处理；不同，则丢弃这个包

* **小知识**

  世界上的巨型网络是由多个小型局域网构成，小型局域网之间是由路由器进行连接，**路由器划分广播域**

### 网络层

* **网络层的由来**

  有了以太网协议、MAC地址、广播的形式发送方式，世界上所有的计算机就都可以彼此通信了，但是世界范围的互联网是由一个个小的局域网组成的，如果采用广播的形式发送，世界上所有的计算机都会收到，可想而知，这个效率非常的低

  **结论：我们必须找出一种方法来区分计算机是否属于同一广播域（子网），如果是，就采用广播的形式发送；如果不是，就采用路由的方式（向不同的广播域分发数据包）**

  网络层使用**ip地址**，使我们能够区分不同的计算机是否属于同一个子网络

  先处理网络地址，再处理MAC地址

* **IP协议**

  规定网络地址的协议，叫做ip协议。他所定义的地址，被称为ip地址，互联网上每一台计算机，都会分配到一个IP地址

  ip地址由32个二进制（每段8位，共4段）组成，四段分为两部分，第一部分代表网络，第二部分代表主机

  **子网掩码：**他是一个32位的二进制，用于判断两台计算机是否属于同一个子网络，网络部分全为1，主机部分全为0，**处于同一个子网络的电脑，他们的IP地址的网络部分必定是相同的**

  **主要作用：为每台计算机分配IP地址，确定哪些计算机在同一个子网络**

* **IP数据包**

  根据IP协议发送的数据包，叫做IP数据包，里面包含IP地址信息

  我们把IP数据包直接放进以太网数据包的”数据“部分，不用修改以太网的规格。

  IP数据包分为"标头"和"数据"两部分："标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。

* **ARP协议**

  地址解析协议，根据IP地址来获取MAC地址的一个网络层协议

  **ARP协议的由来：**通信是基于MAC广播的方式实现的，计算机在发包的时候，获取自身的MAC地址很容易，获取目标主机的MAC地址，就需要通过arp协议。

  **协议的工作原理：**在同一个子网中，ARP首先会发起一个数据包，这个数据包的首部包含**目标主机的IP地址**，然后这个数据包会在数据链路层进行再次包装，生成以太网数据包，最终由以太网以广播的形式给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，相同则返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收消息返回，一次确定目标主机的MAC地址。与此同时，ARP还会将返回的MAC地址与对应的IP地址存在本机的ARP缓存中并保留一段时间，下次请求时直接查询ARP缓存以节约资源

* **路由协议**

  首先通过**IP协议**来判断两台主机是否在同一个子网中，如果在同一个子网中，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包。**如果不在同一个子网**，以太网会把该数据包转发给本子网的网关进行路由。**网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP协议获取目标主机的MAC地址，最终也是以广播的形式将数据包发送给接收方。**完成这个路由协议的物理设备是路由器，路由器扮演者交通枢纽的角色，他会根据信道情况，选择并设定路由，以最佳路径来转发数据包

### 传输层

定义端口，标识应用程序的身份，建立端口到端口的通信

网络层建立：主机到主机的通信

链路层确定了主机的身份MAC地址，网络层定义了主机的IP地址，明确了主机所在的网段，数据包就可以从一台主机到另一台主机了。**但是实际上数据包是从一个主机的某个应用程序发出的，然后由对方的应用程序接收，所以如何标识这台主机上的应用程序呢，就是端口**

<img src="C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210301182007515.png" alt="image-20210301182007515" style="zoom: 80%;" />

Unix系统把主机＋端口叫做**套接字**

#### UDP（不可靠传输）

UDP协议定义了端口。UDP数据包，由标头和数据组成，标头部分8个字节，总长度不超过65535，标头：发出端口和接收端口，数据：具体内容。

把整个UDP数据包放入IP数据包的数据部分。UDP数据包正好放进一个IP数据包

**UDP协议比较简单，一旦数据发出，无法知道对方是否收到，因此可靠性差，为了解决这个问题，提高网络的可靠性，TCP协议诞生了**

![image-20210301205403913](C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210301205403913.png)

#### TCP（可靠传输）

TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们成为套接字（ip协议＋端口号）。**当应用程序希望通过TCP与另一个应用程序通信时，他会发送一个通信请求，这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP将这两个应用程序之间建立一个全双工（双方都可以收发消息）的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到他被一方或者双方关闭为止**

他是可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不会被分割

![image-20210301205352889](C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210301205352889.png)

##### TCP的三次握手

* 端到端的通信——>应用进程之间的通信

* UDP，在传送数据前不需要建立连接，远地主机在接收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是却省去了很多开销，使得它的速度更快。比如对一些实时性要求较高的服务，常常使用的是UDP，对应的应用层协议有：DNS、TFTP、DHCP、SNMP、NFS

* TCP，提供面向连接的服务，在传送数据之前必须先建立连接（连接的意思：双方都需要保存对方的信息IP、port...），数据传送完成后要释放连接，因此TCP是一种可靠的运输服务。但是因为这样不可避免的增加了许多的开销，比如：确认、流量控制。对应的应用层协议主要有SMTP、TELNET、HTTP、FTP

* **三次握手**

  1. TCP报文格式

     TCP报头中的源端口号和目标端口号同IP数据包中的源IP与目的IP唯一确定一条TCP连接

     <img src="C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210301220136804.png" alt="image-20210301220136804" style="zoom: 80%;" />

  2. 为什么要三次握手

     最主要的目的就是双方确认自己与对方的发送和接收是否正常，另外一个目的就是确认双方都支持TCP，告知对方用TCP传输

  3. 报文主要段的意思

     * seq(序号)：表示发送的数据字节流，确保TCP传输有序，对每个字节进行编号
     * ack(确认序号)：发送方期待接收的下一个序列号，接收方接收成功后对数据字节序列号加1。只有ACK为1时才有效
     * ACK：确认序号标志，ACK=1表示确认序号有效，ACK=0表示报文中不含确认序号信息
     * SYN：连接请求序号标志，用于建立连接，SYN=1表示请求连接
     * FIN：结束标志，用于释放连接，FIN=1表示关闭本方数据流

  4. 图解

     <img src="C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210301221150059.png" alt="image-20210301221150059" style="zoom:67%;" />

  5. 三次握手过程

     * **第一次握手**

       起初两端都处于CLOSED关闭状态，Client将标志为SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，此时Client进入SYN-SENT状态，等待Server确认

     * **第二次握手**

       Server接收到数据包后又标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机生成一个seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量

     * **第三次握手**

       Client收到确认后，检查ack是否x+1，ACK是否为1，如果正确则将ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据


##### TCP的四次挥手

1. 图解

   <img src="C:\Users\zhuwanning\AppData\Roaming\Typora\typora-user-images\image-20210302122715247.png" alt="image-20210302122715247" style="zoom: 67%;" />

2. 四次挥手过程

   * 第一次挥手

     客户端发出释放FIN=1（结束标志，用于释放连接），自己的序列号seq=u，进入FIN-WAIT1-1状态

   * 第二次挥手

     服务器接收到客户端的后，发出ACK=1标志和客户端的确认好ack=u+1，自己的序列号为seq=v，进入CLIOSE-WAIT状态

   * 第三次挥手

     客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务端发出释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己的序号seq=w，服务器进入LAST-ACK状态

   * 第四次挥手

     客户端收到回复后，发送确认标志ACK=1，ack=w+1，自己的序列号seq=u+1，客户端进入TIME-WAIT状态（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSED，服务器收到确认后，立刻进入CLOSED状态

3. 为什么三次握手和四次挥手？

   * 三次握手时，服务器同时把ACK和SYN放在一起发送到了客户端那里
   * 四次挥手时，因为双方彼此都建立了连接，因此双方都要释放连接。A向B发送一个释放连接的请求FIN=1，仅仅表示A不再发送数据了，但是A还是可以接收数据，B在收到A发送的释放连接的请求之后，向A发送一个确认。但是此时B还是可以向A发送数据的。然后B向A发送一个断开连接的请求，A收到之后向B发送确认。此时B关闭连接，A关闭连接

4. 为什么客户端还要等待2MSL呢？

   客户端需要保证最后一个发送的报文到服务器，如果A发送完确认之后立马关闭，但是B未收到这个确认，则最后一次确认丢失了，此时A已经关闭连接了，那么B永远也关闭不掉了；A在发送完确认后进入TIME-WAIT状态，如果B未收到，可以请求A重新发送，这样A还有时间重发，重新2MSL计时

### 应用层

应用层收到“传输层”的数据，必定要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读

应用层的作用：规定好应用程序的数据格式

应用层协议：HTTP、FTP、DNS

举例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW等，那么，必定有不同协议规定电子邮件、网页数据的格式。这些应用程序协议就构成了应用层

